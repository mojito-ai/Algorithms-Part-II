# Algorithms-Part-II

![Algorithms-Part-II](https://i.ytimg.com/vi/60BKdKQzLbo/maxresdefault.jpg)

#### Essential information that every serious programmer needs to know about algorithms and data structures, with emphasis on applications and scientific performance analysis of Java implementations. Designed in accordance with Princeton University MOOC (Coursera) and programmed in Java.

[Link to the course](https://online.princeton.edu/node/166)

#### The git-repo includes algorithms used widely in computational science, computational biology and in all IT sectors. The algorithms are divided into the following categories:

1. **Undirected Graphs:** We define an undirected graph API and consider the adjacency-matrix and adjacency-lists representations. We introduce two classic algorithms for searching a graph—depth-first search and breadth-first search. We also consider the problem of computing connected components and conclude with related problems and applications.

2. **Directed Graphs:** We begin with depth-first search and breadth-first search in digraphs and describe applications ranging from garbage collection to web crawling. Next, we introduce a depth-first search based algorithm for computing the topological order of an acyclic digraph. Finally, we implement the Kosaraju-Sharir algorithm for computing the strong components of a digraph.

3. **Minimum Spanning Trees:** We study the minimum spanning tree problem. We begin by considering a generic greedy algorithm for the problem. Next, we consider and implement two classic algorithm for the problem—Kruskal's algorithm and Prim's algorithm. We conclude with some applications and open problems.

4. **Shortest Paths:** We study shortest-paths problems. We begin by analyzing some basic properties of shortest paths and a generic algorithm for the problem. We introduce and analyze Dijkstra's algorithm for shortest-paths problems with nonnegative weights. Next, we consider an even faster algorithm for DAGs, which works even if the weights are negative. We conclude with the Bellman–Ford–Moore algorithm for edge-weighted digraphs with no negative cycles. We also consider applications ranging from content-aware fill to arbitrage.

5. #### **Maximum Flow and Minimum Cut**
6. #### **Radix Sorts**
7. #### **Tries**
8. #### **Substring Search**
9. #### **Regular Expressions**
10. #### **Data Compression**
11. #### **Reductions**
12. #### **Linear Programming**
13. #### **Intractability**

## **Author: Mohit Sharma**
## **Email: msharma3@me.iitr.ac.in**

#### Proper care has been taken to ensure that the speed analysis and the space analysis is done. There is a classic space/time tradeoff and the author has ensured to ensure fast processing algorithms in accordance with Moore's Law. Still there might be several errors or performance bugs at some places. Users are welcomed to create PR's or fork the repository to create better performing algorithms.

### > Algorithms: A common language for Nature, Human & Computer. - Avi Widgerson

### > Beware of bugs in the above code; I have only proved it correct, not tried it. - Sir Donald Knuth
